using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Windows.Forms;
using KVLib;
using System.Collections;

namespace WorldSmith.DataClasses
{
    static class DotaData
    {
        public static string KVHeader = "//This script generated by WorldSmith" + Environment.NewLine
            + "//Get WorldSmith at TODO: Put a URL here" + Environment.NewLine;


        public static string VPKPath = "dota_ugc" + Path.DirectorySeparatorChar + "game" + Path.DirectorySeparatorChar + "dota_imported" + Path.DirectorySeparatorChar + "pak01_dir.vpk";

        #region Unit Data Lists
        public static List<DotaUnit> DefaultUnits = new List<DotaUnit>();

        public static List<DotaUnit> OverriddenUnits = new List<DotaUnit>();

        public static List<DotaUnit> CustomUnits = new List<DotaUnit>();

        public static List<DotaHero> DefaultHeroes = new List<DotaHero>();

        public static List<DotaHero> OverridenHeroes = new List<DotaHero>();

        public static List<DotaHero> CustomHeroes = new List<DotaHero>();

        public static IEnumerable<DotaHero> AllCustomHeroes = OverridenHeroes.Union(CustomHeroes);
        public static IEnumerable<DotaHero> AllHeroes = DefaultHeroes.Union(AllCustomHeroes);       

        public static IEnumerable<DotaUnit> AllCustomUnits = OverriddenUnits.Union(CustomUnits);
        public static IEnumerable<DotaUnit> AllUnits = DefaultUnits.Union(CustomUnits);            
        #endregion

        #region Ability Data Lists
        public static List<DotaAbility> DefaultAbilities = new List<DotaAbility>();

        public static List<DotaAbility> OverridenAbilities = new List<DotaAbility>();

        public static List<DotaAbility> CustomAbilities = new List<DotaAbility>();

        public static IEnumerable<DotaAbility> AllAbilities = DefaultAbilities.Union(CustomAbilities).Union(OverridenAbilities);

        #endregion

        #region Item Data Lists
        public static List<DotaItem> DefaultItems = new List<DotaItem>();

        public static List<DotaItem> OverridenItems = new List<DotaItem>();

        public static List<DotaItem> CustomItems = new List<DotaItem>();

        public static IEnumerable<DotaItem> AllItems = DefaultItems.Union(CustomItems).Union(OverridenItems);
        #endregion



        public static IEnumerable<DotaDataObject> AllClasses = AllUnits.Cast<DotaDataObject>()
            .Union(AllAbilities.Cast<DotaDataObject>())
            .Union(AllItems.Cast<DotaDataObject>());

        public static IList FindListThatHasObject(DotaDataObject ddo)
        {
            //I hate writing code like this


            DotaDataObject.DataObjectInfo.ObjectDataClass ObjectClass = ddo.ObjectInfo.ObjectClass;
            if(ddo is DotaHero)
            {
                if (ObjectClass == DotaDataObject.DataObjectInfo.ObjectDataClass.Default)
                {
                    return DefaultHeroes;
                }
                else if (ObjectClass == DotaDataObject.DataObjectInfo.ObjectDataClass.Override)
                {
                    return OverridenHeroes;
                }
                else
                {
                    return CustomHeroes;
                }
            }
            else if(ddo is DotaUnit)
            {
                if(ObjectClass == DotaDataObject.DataObjectInfo.ObjectDataClass.Default)
                {
                    return DefaultUnits;
                }
                else if(ObjectClass == DotaDataObject.DataObjectInfo.ObjectDataClass.Override)
                {
                    return OverriddenUnits;
                }
                else
                {
                    return CustomUnits;
                }
            }
            else if(ddo is DotaItem)
            {
                if(ObjectClass == DotaDataObject.DataObjectInfo.ObjectDataClass.Default)
                {
                    return DefaultItems;
                }
                else if(ObjectClass == DotaDataObject.DataObjectInfo.ObjectDataClass.Override)
                {
                    return OverridenItems;
                }
                else
                {
                    return CustomItems;
                }
            }
            else if(ddo is DotaAbility)
            {
                if(ObjectClass == DotaDataObject.DataObjectInfo.ObjectDataClass.Default)
                {
                    return DefaultAbilities;
                }
                else if(ObjectClass == DotaDataObject.DataObjectInfo.ObjectDataClass.Override)
                {
                    return OverridenAbilities;
                }
                else
                {
                    return CustomAbilities;
                }
            }
            throw new ArgumentException("Don't have a list for that type");
        }

        public static string NPCScriptPath = "scripts" + Path.DirectorySeparatorChar + "npc" + Path.DirectorySeparatorChar;
        public static string CustomHeroesFile = NPCScriptPath + "npc_heroes_custom.txt";
        public static string CustomUnitsFile = NPCScriptPath + "npc_units_custom.txt";
        public static string CustomAbilityFile = NPCScriptPath + "npc_abilities_custom.txt";
        public static string CustomItemsFile = NPCScriptPath + "npc_items_custom.txt";

        public const string DefaultUnitsFile = "scripts/npc/npc_units.txt";
        public const string DefaultHeroesFile = "scripts/npc/npc_heroes.txt";
        public const string DefaultAbilitiesFile = "scripts/npc/npc_abilities.txt";
        public const string DefaultItemsFile = "scripts/npc/items.txt";

        #region HLLib Usage
        public static void LoadFromVPK(string vpkPath)
        {
            if(!Directory.Exists("cache")) Directory.CreateDirectory("cache");

            string path = Properties.Settings.Default.DotaDir + Path.DirectorySeparatorChar + VPKPath;
            HLLib.hlInitialize();

            // Get the package type from the filename extension.
            HLLib.HLPackageType PackageType = HLLib.hlGetPackageTypeFromName(path);

            HLLib.HLFileMode OpenMode = HLLib.HLFileMode.HL_MODE_READ |
                //HLLib.HLFileMode.HL_MODE_QUICK_FILEMAPPING |
                HLLib.HLFileMode.HL_MODE_VOLATILE;

            uint PackageID;

            ErrorCheck(HLLib.hlCreatePackage(PackageType, out PackageID));            

            ErrorCheck(HLLib.hlBindPackage(PackageID));

            ErrorCheck(HLLib.hlPackageOpenFile(path, (uint)OpenMode));           
            
        }


        private static string ReadTextFromHLLibStream(IntPtr Stream)
        {
            HLLib.HLFileMode mode = HLLib.HLFileMode.HL_MODE_READ;

            ErrorCheck(HLLib.hlStreamOpen(Stream, (uint)mode));

            StringBuilder str = new StringBuilder();

            char ch;
            while (HLLib.hlStreamReadChar(Stream, out ch))
            {
                str.Append(ch);
            }

            HLLib.hlStreamClose(Stream);

            return str.ToString();
        }

        public static string ReadAllText(string filePath)
        {
            IntPtr root = HLLib.hlPackageGetRoot();

            IntPtr file = HLLib.hlFolderGetItemByPath(root, filePath, HLLib.HLFindType.HL_FIND_FILES);

            IntPtr stream;
            ErrorCheck(HLLib.hlPackageCreateStream(file, out stream));

            string text = ReadTextFromHLLibStream(stream);

            return text;
        }

        public static void ErrorCheck(bool ret)
        {
            if (!ret)
            {
                MessageBox.Show("Error reading pak01_dir.vpk.\n\n The error reported was: " + HLLib.hlGetString(HLLib.HLOption.HL_ERROR_LONG_FORMATED), "Error opening .pak", MessageBoxButtons.OK);
                Shutdown();
                Properties.Settings.Default.AddOnPath = String.Empty;
                Properties.Settings.Default.Save();
                Environment.Exit(0);
            }
        }

        public static void Shutdown()
        {
            HLLib.hlShutdown();
        }

        #endregion       

        #region LoadData
        public static void ReadScriptFromVPK<T>(string filePath, List<T> ListToInsert) where T : DotaDataObject
        {
            IntPtr root = HLLib.hlPackageGetRoot();

            IntPtr file = HLLib.hlFolderGetItemByPath(root, filePath, HLLib.HLFindType.HL_FIND_FILES);

            IntPtr stream;
            ErrorCheck(HLLib.hlPackageCreateStream(file, out stream));

            string unitsText = ReadTextFromHLLibStream(stream);

            KeyValue rootkv = KVLib.KVParser.ParseKeyValueText(unitsText);

            foreach (KeyValue kv in rootkv.Children)
            {
                if (!kv.HasChildren) continue; //Get rid of that pesky "Version" "1" key

                T unit = typeof(T).GetConstructor(Type.EmptyTypes).Invoke(new object[] { }) as T;
                unit.LoadFromKeyValues(kv);

                unit.ObjectInfo.FromVPK = true;
                unit.ObjectInfo.ObjectClass = DotaDataObject.DataObjectInfo.ObjectDataClass.Default;
                unit.ObjectInfo.OriginatingFile = filePath;

                ListToInsert.Add(unit);
            }
            return;
        }

       
        public static void ReadOverride<T>(string file, List<T> ListToLoadInto) where T : DotaDataObject
        {
            if (!File.Exists(Properties.Settings.Default.LoadedAddonDirectory + file)) return;

            ListToLoadInto.Clear();
            try
            {
                KeyValue doc = KVParser.ParseKeyValueText(File.ReadAllText(Properties.Settings.Default.LoadedAddonDirectory + file));
                foreach(KeyValue hero in doc.Children)
                {
                    try
                    {
                        if (!hero.HasChildren) continue;
                        T unit = typeof(T).GetConstructor(Type.EmptyTypes).Invoke(Type.EmptyTypes) as T;
                        unit.LoadFromKeyValues(hero);

                        unit.ObjectInfo.FromVPK = false;
                        unit.ObjectInfo.OriginatingFile = file;
                        //TODO: Determine if it's an override
                        unit.ObjectInfo.ObjectClass = DotaDataObject.DataObjectInfo.ObjectDataClass.Custom;

                        ListToLoadInto.Add(unit);
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("ERROR in file:\"" + file + "\" on " + hero.Key);
                        Console.WriteLine(e.Message);
                        Console.WriteLine(e.StackTrace);
                        Console.WriteLine("");
                        Console.WriteLine("");
                    }
                }
            }
            catch (Exception e)
            {
                //WE HAD A SYNTAX ERROR OR SOMETHING
                Console.WriteLine("SYNTAX ERROR in file:\"" + file + "\"");
                Console.WriteLine(e.Message);
                Console.WriteLine("");
                Console.WriteLine("");
            }
        }
        #endregion

        #region SaveData
        public static void SaveUnits()
        {          
            SaveList(CustomUnits, "DOTAUnits", "npc_units_custom.txt");
            SaveList(OverridenHeroes, "DOTAHeroes", "npc_heroes_custom.txt");
            SaveList(CustomAbilities, "DOTAAbilities", "npc_abilities_custom.txt");
        }

        public static void SaveList<T>(List<T> list, string RootKey, string outputFileName) where T : DotaDataObject
        {
            string path = Properties.Settings.Default.LoadedAddonDirectory + Path.DirectorySeparatorChar
                + "scripts" + Path.DirectorySeparatorChar + "npc" + Path.DirectorySeparatorChar;
            if (!Directory.Exists(path)) Directory.CreateDirectory(path);

            KeyValue doc = new KeyValue(RootKey);

            foreach (T unit in list)
            {
                doc += unit.SaveToKV();
            }

            File.WriteAllText(path +outputFileName, KVHeader + doc.ToString());
        }
        #endregion


    }
}
